## Socket이란?
소켓은 네트워크 통신을 위한 양쪽 끝단을 의미합니다.<br/>
IP 주소와 포트 번호의 조합으로 통신 세션을 설정하고 데이터를 송수신 하는데에 사용합니다.<br/>
서버 측과 클라이언트 측 (양 끝단)에 소켓을 각각 생성하고, 해당 소켓 간에 통신을 하여 데이터를 송수신한다고 생각하면 됩니다.
서버측 소켓은 포트당 하나씩만 생성할 수 있고 클라이언트 측 소켓은 여러개 생성하여 하나의 서버 소켓에 통신할 수 있습니다.<br/>

## Socket 통신
네트워크를 통해 두 프로그램(보통 서버와 클라이언트)이 소켓(Socket)을 이용하여 데이터를 주고받는 통신 방식을 말합니다.<br/>

소켓 통신은 아래와 같은 순서로 이루어집니다.


![img.png](img.png)

## 정상적인 연결 Flow
### 클라이언트 소켓
1. socket() : 서버에 연결하기 위한 소켓을 생성합니다.
2. connect() : 서버 소켓에서 bind하여 할당받은 ip, port에 연결 요청을 합니다.
3. 연결 요청에 대해서 서버측에서 응답(accept)이 오면 연결이 되어 socket descriptor(소켓 자원을 식별하기 위한 번호)가 반환되고 데이터를 송수신할 준비를 합니다.
4. send() / recv() : 서버 소켓과 통신을 주고 받습니다.
5. close() : 소켓을 닫습니다.

### 서버측 소켓
1. socket() : 클라이언트와 통신하기 위한 준비용 소켓(리스닝 소켓, listening socket)을 생성하는 것입니다. 이 단계에서는 실제 통신이 이루어지지 않으며, 단순히 통신 대기용 소켓을 만드는 과정입니다.
2. bind() : 생성한 소켓에 대해 IP 주소와 Port 번호를 할당합니다. <br/>
(참고 : 운영체제는 한 컴퓨터 안에서 여러개의 프로세스를 실행십니다. 이때 어떤 소켓이 어떤 ip, port를 사용할지 지정해줘야합니다.)
3. listen() :  클라이언트의 연결 요청을 대기하는 상태로 전환합니다.
4. accept() : 클라이언트측에서 연결 요청(connect)이 오면 수락 후 통신을 위한 소켓을 생성합니다.
5. send() / recv() : 클라이언트 소켓과 통신을 주고 받습니다.
6. close() : 소켓을 닫습니다.



## 연결 실패 시
### 클라이언트 소켓
1. socket() : 서버에 연결하기 위한 소켓을 생성합니다.
2. connect() : 서버 소켓에서 bind하여 할당받은 ip, port에 연결 요청을 합니다.
3. 서버측 소켓에서 연결을 거부할 시 대기큐에 저장 -> 큐의 크기가 커지면 새로운 요청 거절
### 서버측 소켓
1. socket() : 클라이언트와 통신하기 위한 준비용 소켓(리스닝 소켓, listening socket)을 생성하는 것입니다. 이 단계에서는 실제 통신이 이루어지지 않으며, 단순히 통신 대기용 소켓을 만드는 과정입니다.
2. bind() : 생성한 소켓에 대해 IP 주소와 Port 번호를 할당합니다. <br/>
   (참고 : 운영체제는 한 컴퓨터 안에서 여러개의 프로세스를 실행십니다. 이때 어떤 소켓이 어떤 ip, port를 사용할지 지정해줘야합니다.)
3. listen() :  클라이언트의 연결 요청을 대기하는 상태로 전환합니다.
4. accept() : 클라이언트 측 요청 거절

### 예시
스프링 애플리케이션을 띄우게 되면 아래와 같은 로그를 접하게 됩니다.

![img_1.png](img_1.png)

여기서 socket()은 내부적으로 수행되어 소켓을 생성하고 아래와 같은 로그 부분에서 bind()가 수행이 되어 ip, port를 할당 받습니다.

![img_2.png](img_2.png)

그리고 클라이언트 연결 요청을 받을 수 있는 대기상태로 전환이 됩니다.<br/>
아래 명령어를 수행하면 현재 실행중인 애플리케이션의 상태값이 listen인것을 확인할 수 있습니다.
```aiignore
lsof -i :8080
```
8080은 톰켓의 기본 port 번호입니다.

![img_3.png](img_3.png)
